import type { Child, BirthdayConfig } from '../types';

/**
 * Calculate when the custody plan expires based on the youngest child.
 * The plan expires when the youngest child reaches their custody end age.
 *
 * @param children - Array of children in the custody arrangement
 * @returns ISO date string (YYYY-MM-DD) when the plan expires, or null if no children
 *
 * @example
 * ```typescript
 * const children = [
 *   { id: '1', name: 'Alice', birthdate: '2015-03-15', custodyEndAge: 18 },
 *   { id: '2', name: 'Bob', birthdate: '2018-07-20', custodyEndAge: 18 },
 * ];
 * calculatePlanExpiration(children); // Returns '2036-07-20' (when Bob turns 18)
 * ```
 */
export function calculatePlanExpiration(children: Child[]): string | null {
  if (children.length === 0) return null;

  // Find the youngest child (latest birthdate)
  const youngest = children.reduce((prev, curr) =>
    prev.birthdate > curr.birthdate ? prev : curr
  );

  // Calculate when they turn custodyEndAge
  // Use T00:00:00 to avoid timezone issues
  const birthDate = new Date(youngest.birthdate + 'T00:00:00');
  birthDate.setFullYear(birthDate.getFullYear() + youngest.custodyEndAge);
  return birthDate.toISOString().split('T')[0];
}

/**
 * Generate birthday holiday configs from children.
 * Creates a birthday entry for each child with their birthdate.
 * Default assignment is alternate odd/even years.
 *
 * @param children - Array of children in the custody arrangement
 * @returns Array of BirthdayConfig objects for each child
 *
 * @example
 * ```typescript
 * const children = [{ id: '1', name: 'Emma', birthdate: '2018-05-15', custodyEndAge: 18 }];
 * generateChildBirthdayHolidays(children);
 * // Returns [{ id: 'birthday-1', name: "Emma's Birthday", type: 'child', month: 5, day: 15, ... }]
 * ```
 */
export function generateChildBirthdayHolidays(children: Child[]): BirthdayConfig[] {
  return children
    .filter((child) => child.birthdate) // Only process children with valid birthdates
    .map((child) => ({
      id: `birthday-${child.id}`,
      name: `${child.name || 'Child'}'s Birthday`,
      type: 'child' as const,
      month: parseInt(child.birthdate.split('-')[1], 10),
      day: parseInt(child.birthdate.split('-')[2], 10),
      defaultAssignment: 'alternate-odd-even' as const,
      linkedChildId: child.id,
      isAutoGenerated: true,
    }));
}

/**
 * Sync birthday holiday when child info changes.
 * Updates the birthday name and date to match the child's current info.
 * Only updates birthdays that are linked to the child via linkedChildId.
 *
 * @param birthdays - Current array of birthday configs
 * @param child - The child whose info has changed
 * @returns Updated array of birthday configs
 *
 * @example
 * ```typescript
 * const birthdays = [{ id: 'birthday-1', name: "Emma's Birthday", linkedChildId: '1', ... }];
 * const updatedChild = { id: '1', name: 'Emily', birthdate: '2018-06-20', custodyEndAge: 18 };
 * syncBirthdayWithChild(birthdays, updatedChild);
 * // Returns birthday with name: "Emily's Birthday", month: 6, day: 20
 * ```
 */
export function syncBirthdayWithChild(
  birthdays: BirthdayConfig[],
  child: Child
): BirthdayConfig[] {
  return birthdays.map((birthday) => {
    if (birthday.linkedChildId === child.id && child.birthdate) {
      return {
        ...birthday,
        name: `${child.name || 'Child'}'s Birthday`,
        month: parseInt(child.birthdate.split('-')[1], 10),
        day: parseInt(child.birthdate.split('-')[2], 10),
      };
    }
    return birthday;
  });
}

/**
 * Remove a child's birthday from the birthday list.
 * Removes the birthday that is linked to the specified child ID.
 *
 * @param birthdays - Current array of birthday configs
 * @param childId - The ID of the child whose birthday should be removed
 * @returns Updated array of birthday configs without the child's birthday
 *
 * @example
 * ```typescript
 * const birthdays = [
 *   { id: 'birthday-1', linkedChildId: '1', ... },
 *   { id: 'birthday-2', linkedChildId: '2', ... },
 * ];
 * removeChildBirthday(birthdays, '1');
 * // Returns [{ id: 'birthday-2', linkedChildId: '2', ... }]
 * ```
 */
export function removeChildBirthday(
  birthdays: BirthdayConfig[],
  childId: string
): BirthdayConfig[] {
  return birthdays.filter((birthday) => birthday.linkedChildId !== childId);
}

/**
 * Sync all birthdays with the current list of children.
 * - Creates birthdays for new children (with valid birthdates)
 * - Updates existing birthdays when child info changes
 * - Removes birthdays for children that no longer exist
 * - Preserves manually added birthdays (no linkedChildId)
 *
 * @param birthdays - Current array of birthday configs
 * @param children - Current array of children
 * @returns Updated array of birthday configs synced with children
 *
 * @example
 * ```typescript
 * const birthdays = [{ id: 'birthday-1', linkedChildId: '1', name: "Emma's Birthday", ... }];
 * const children = [
 *   { id: '1', name: 'Emily', birthdate: '2018-05-15', custodyEndAge: 18 },  // renamed
 *   { id: '2', name: 'Jack', birthdate: '2020-03-10', custodyEndAge: 18 },   // new
 * ];
 * syncBirthdaysWithChildren(birthdays, children);
 * // Returns array with Emily's Birthday (updated) and Jack's Birthday (new)
 * ```
 */
export function syncBirthdaysWithChildren(
  birthdays: BirthdayConfig[],
  children: Child[]
): BirthdayConfig[] {
  const childIds = new Set(children.map((c) => c.id));

  // Step 1: Keep manual birthdays (no linkedChildId) and parent birthdays
  const manualAndParentBirthdays = birthdays.filter(
    (b) => !b.linkedChildId || !b.isAutoGenerated
  );

  // Step 2: Keep auto-generated birthdays for children that still exist and update them
  const existingChildBirthdays = birthdays
    .filter((b) => b.linkedChildId && b.isAutoGenerated && childIds.has(b.linkedChildId))
    .map((birthday) => {
      const child = children.find((c) => c.id === birthday.linkedChildId);
      if (child && child.birthdate) {
        return {
          ...birthday,
          name: `${child.name || 'Child'}'s Birthday`,
          month: parseInt(child.birthdate.split('-')[1], 10),
          day: parseInt(child.birthdate.split('-')[2], 10),
        };
      }
      return birthday;
    });

  // Step 3: Find children who don't have a birthday yet (with valid birthdates)
  const existingLinkedIds = new Set(
    birthdays.filter((b) => b.linkedChildId).map((b) => b.linkedChildId)
  );
  const newChildren = children.filter(
    (c) => !existingLinkedIds.has(c.id) && c.birthdate
  );
  const newBirthdays = generateChildBirthdayHolidays(newChildren);

  // Combine all birthdays: manual/parent + existing child + new child
  return [...manualAndParentBirthdays, ...existingChildBirthdays, ...newBirthdays];
}
